<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relógio Flip 3D - Sincronização Total de Fontes</title>
    
    <!-- Importação de Fontes do Google -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@900&family=JetBrains+Mono:wght@800&family=Bebas+Neue&family=Montserrat:wght@900&family=Inter:wght@900&family=Oswald:wght@700&family=Ubuntu:wght@700&family=Playfair+Display:wght@900&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010101; font-family: 'Inter', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        #ui-bottom {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 150, 255, 0.4);
            text-align: center;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 9px;
            text-shadow: 0 0 10px rgba(0, 100, 255, 0.5);
        }

        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #settings-btn:hover { background: rgba(0, 150, 255, 0.2); transform: rotate(45deg); }
        #settings-btn svg { width: 20px; height: 20px; fill: currentColor; }

        #settings-panel {
            position: absolute;
            top: 70px;
            right: 20px;
            width: 260px;
            max-height: 85vh;
            overflow-y: auto;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            color: white;
            display: none;
            box-shadow: 0 12px 40px rgba(0,0,0,0.8);
            z-index: 99;
        }
        #settings-panel.active { display: block; animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95) translateY(-10px); } to { opacity: 1; transform: scale(1) translateY(0); } }

        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; font-size: 9px; text-transform: uppercase; margin-bottom: 6px; opacity: 0.5; font-weight: 700; letter-spacing: 1px; }
        .control-group input, .control-group select { width: 100%; cursor: pointer; background: #1a1a1a; color: white; border: 1px solid #333; border-radius: 6px; padding: 8px; font-size: 11px; outline: none; }
        
        .panel-title { font-size: 13px; font-weight: 800; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 12px; letter-spacing: 2px; text-align: center; color: #0096ff; }
        
        #settings-panel::-webkit-scrollbar { width: 4px; }
        #settings-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }
    </style>
</head>
<body>
    <button id="settings-btn" title="Configurações">
        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
    </button>

    <div id="settings-panel">
        <div class="panel-title">MECANISMO</div>
        
        <div class="control-group">
            <label>Tipo de Fonte</label>
            <select id="font-family">
                <option value="'Inter', sans-serif" selected>Inter (Clássica)</option>
                <option value="'Bebas Neue', cursive">Bebas Neue (Display)</option>
                <option value="'Roboto', sans-serif">Roboto</option>
                <option value="'JetBrains Mono', monospace">JetBrains Mono (Tech)</option>
                <option value="'Oswald', sans-serif">Oswald</option>
                <option value="'Montserrat', sans-serif">Montserrat</option>
                <option value="'Ubuntu', sans-serif">Ubuntu</option>
                <option value="'Playfair Display', serif">Playfair Display</option>
                <option value="Impact, sans-serif">Impact</option>
                <option value="'Courier New', monospace">Courier New</option>
            </select>
        </div>

        <div class="control-group">
            <label>Ajuste Vertical Ótico</label>
            <input type="range" id="y-offset" min="-50" max="50" step="1" value="0">
        </div>

        <div class="control-group">
            <label>Cor dos Números</label>
            <input type="color" id="font-color" value="#FFFFFF">
        </div>

        <div class="control-group">
            <label>Cor do Housing</label>
            <input type="color" id="box-color" value="#050505">
        </div>

        <div class="control-group">
            <label>Cor do Brilho (Neon)</label>
            <input type="color" id="glow-color" value="#0066ff">
        </div>

        <div class="control-group">
            <label>Distância de Projeção</label>
            <input type="range" id="flip-projection" min="0" max="0.5" step="0.01" value="0.10">
        </div>

        <div class="control-group">
            <label>Velocidade Mecânica</label>
            <input type="range" id="flip-speed" min="1" max="10" step="0.5" value="4.5">
        </div>

        <div class="control-group">
            <label>Exposição de Luz</label>
            <input type="range" id="light-intensity" min="0" max="3" step="0.1" value="1.0">
        </div>
    </div>

    <div id="ui-bottom">Sincronização Ativa • Motor Flip 3D</div>
    <div id="canvas-container"></div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vNormal;
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform sampler2D map;
        uniform float shadowIntensity;
        uniform vec3 glowColor;
        uniform bool uIsTop;

        void main() {
            vec4 texColor = texture2D(map, vUv);
            vec3 lightDir = normalize(vec3(5.0, 10.0, 15.0));
            float diff = max(dot(vNormal, lightDir), 0.4);
            
            float unifiedY = uIsTop ? (vUv.y * 0.5 + 0.5) : (vUv.y * 0.5);
            float dist = distance(vec2(vUv.x, unifiedY), vec2(0.5, 0.5));
            float glow = pow(max(0.0, 1.0 - dist * 1.6), 3.0);
            vec3 finalGlow = glowColor * glow * 1.8;
            
            float edgeShadow = smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.9, vUv.y);
            edgeShadow = mix(1.0, edgeShadow, shadowIntensity);

            vec3 color;
            float luminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
            if(luminance < 0.1) { 
                color = finalGlow * diff * edgeShadow;
            } else { 
                color = texColor.rgb * (diff + 0.3) * edgeShadow;
            }

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        let scene, camera, renderer, controls, dirLight, ambientLight, clockCase;
        const clock = new THREE.Clock();
        const flaps = [];
        
        const params = {
            glowColor: new THREE.Color(0x0066ff),
            fontColor: "#FFFFFF",
            boxColor: "#050505",
            fontFamily: "'Inter', sans-serif",
            yOffset: 0,
            flipSpeed: 4.5,
            flipProjection: 0.10,
            lightIntensity: 1.0,
            ambientIntensity: 0.25
        };

        class FlipUnit {
            constructor(x, label, limit) {
                this.group = new THREE.Group();
                this.group.position.x = x;
                this.limit = limit;
                this.labelStr = label;
                this.currentVal = -1;
                this.targetVal = 0;
                this.animating = false;
                this.progress = 0;

                this.topBack = this.createHalf(true, -0.005);
                this.botBack = this.createHalf(false, -0.005);
                this.group.add(this.topBack);
                this.group.add(this.botBack);

                this.flipper = new THREE.Group();
                this.flipperFront = this.createHalf(true, 0.005);
                this.flipperBack = this.createHalf(false, 0.005);
                this.flipperBack.rotation.x = Math.PI;
                this.flipper.add(this.flipperFront);
                this.flipper.add(this.flipperBack);
                this.group.add(this.flipper);

                const hinge = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 2.1, 16),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 0.8, roughness: 0.2 })
                );
                hinge.rotation.z = Math.PI / 2;
                this.group.add(hinge);

                this.addLabel(this.labelStr);
                scene.add(this.group);
            }

            createHalf(isTop, zOffset) {
                const geo = new THREE.PlaneGeometry(2, 1.4, 1, 1);
                if (isTop) geo.translate(0, 0.7, zOffset);
                else geo.translate(0, -0.7, zOffset);

                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 512;
                const texture = new THREE.CanvasTexture(canvas);
                texture.anisotropy = 16;

                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        map: { value: texture },
                        shadowIntensity: { value: 0.15 },
                        glowColor: { value: params.glowColor },
                        uIsTop: { value: isTop }
                    },
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.userData = { canvas, ctx: canvas.getContext('2d'), texture, isTop, mat };
                return mesh;
            }

            addLabel(text) {
                if (this.labelMesh) this.group.remove(this.labelMesh);
                
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = params.fontColor + '33';
                ctx.font = `bold 28px ${params.fontFamily}`;
                ctx.textAlign = 'center';
                ctx.fillText(text.toUpperCase(), 128, 42);
                
                const tex = new THREE.CanvasTexture(canvas);
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.4), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
                mesh.position.set(0, -2.2, 0.1);
                this.group.add(mesh);
                this.labelMesh = mesh;
            }

            updateTexture(mesh, val) {
                const { ctx, isTop, texture } = mesh.userData;
                const safeVal = Math.max(0, val);
                const str = safeVal < 10 ? '0' + safeVal : '' + safeVal;
                
                ctx.fillStyle = '#000000'; 
                ctx.fillRect(0, 0, 512, 512);

                let fontSize = 440; 
                const maxTextWidth = 480; 
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = params.fontColor; 

                // Forçar fonte a ser aplicada
                ctx.font = `900 ${fontSize}px ${params.fontFamily}`;
                let metrics = ctx.measureText(str);
                
                if (metrics.width > maxTextWidth) {
                    fontSize = Math.floor(fontSize * (maxTextWidth / metrics.width));
                    ctx.font = `900 ${fontSize}px ${params.fontFamily}`;
                }
                
                const drawY = isTop ? 512 : 0;
                ctx.fillText(str, 256, drawY + params.yOffset);
                
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                if (isTop) ctx.fillRect(0, 508, 512, 4);
                else ctx.fillRect(0, 0, 512, 4);

                texture.needsUpdate = true;
            }

            refreshAllTextures() {
                const cur = Math.max(0, this.currentVal);
                const nxt = this.animating ? this.targetVal : (cur + 1) % this.limit;
                
                // Redesenha vigorosamente as 4 placas
                this.updateTexture(this.topBack, nxt);
                this.updateTexture(this.botBack, cur);
                this.updateTexture(this.flipperFront, cur);
                this.updateTexture(this.flipperBack, nxt);
                
                this.addLabel(this.labelStr);
            }

            setValues(current, next) {
                if (current === this.currentVal && !this.animating) return;
                this.currentVal = current;
                this.targetVal = next;
                this.animating = true;
                this.progress = 0;
                this.refreshAllTextures();
            }

            update(dt) {
                if (!this.animating) return;
                this.progress += dt * params.flipSpeed; 
                if (this.progress >= 1) {
                    this.progress = 1;
                    this.animating = false;
                    this.flipper.rotation.x = 0;
                    this.flipper.position.z = 0;
                    // Ao terminar o flip, atualizamos a base estática para o valor final
                    this.updateTexture(this.botBack, this.targetVal);
                }
                const eased = Math.pow(this.progress, 3);
                this.flipper.rotation.x = eased * Math.PI;
                this.flipper.position.z = Math.sin(this.progress * Math.PI) * params.flipProjection;
                
                const pulse = 0.2 + Math.sin(this.progress * Math.PI) * 0.4;
                this.flipperFront.material.uniforms.shadowIntensity.value = 0.15 + pulse;
                this.flipperBack.material.uniforms.shadowIntensity.value = 0.15 + pulse;
            }

            updateGlowColor(color) {
                [this.topBack, this.botBack, this.flipperFront, this.flipperBack].forEach(m => {
                    m.userData.mat.uniforms.glowColor.value = color;
                });
            }
        }

        async function globalRefresh() {
            // Sincronização definitiva com o motor de fontes
            await document.fonts.ready;
            // Carregar explicitamente a fonte selecionada
            try {
                await document.fonts.load(`900 20px ${params.fontFamily}`);
            } catch(e) {}
            
            // Forçar redesenho em todas as unidades (Horas, Minutos, Segundos)
            requestAnimationFrame(() => {
                flaps.forEach(f => f.refreshAllTextures());
            });
        }

        function initUI() {
            const btn = document.getElementById('settings-btn');
            const panel = document.getElementById('settings-panel');
            
            btn.onclick = (e) => {
                e.stopPropagation();
                panel.classList.toggle('active');
            };

            document.getElementById('font-family').onchange = (e) => {
                params.fontFamily = e.target.value;
                globalRefresh();
            };

            document.getElementById('y-offset').oninput = (e) => {
                params.yOffset = parseInt(e.target.value);
                // Atualização instantânea sem await
                flaps.forEach(f => f.refreshAllTextures());
            };

            document.getElementById('font-color').oninput = (e) => {
                params.fontColor = e.target.value;
                globalRefresh();
            };

            document.getElementById('box-color').oninput = (e) => {
                params.boxColor = e.target.value;
                clockCase.material.color.set(params.boxColor);
            };

            document.getElementById('glow-color').oninput = (e) => {
                params.glowColor.set(e.target.value);
                flaps.forEach(f => f.updateGlowColor(params.glowColor));
                const uiBot = document.getElementById('ui-bottom');
                uiBot.style.color = e.target.value + '88';
                uiBot.style.textShadow = `0 0 12px ${e.target.value}`;
            };

            document.getElementById('flip-projection').oninput = (e) => params.flipProjection = parseFloat(e.target.value);
            document.getElementById('flip-speed').oninput = (e) => params.flipSpeed = parseFloat(e.target.value);
            document.getElementById('light-intensity').oninput = (e) => dirLight.intensity = parseFloat(e.target.value);

            window.onclick = () => panel.classList.remove('active');
            panel.onclick = (e) => e.stopPropagation();
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(38, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.0, 11);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;

            ambientLight = new THREE.AmbientLight(0xffffff, params.ambientIntensity);
            scene.add(ambientLight);
            dirLight = new THREE.DirectionalLight(0xffffff, params.lightIntensity);
            dirLight.position.set(5, 10, 15);
            scene.add(dirLight);

            // Iniciar com valores negativos para forçar o primeiro flip
            flaps.push(new FlipUnit(-2.6, "Horas", 24));
            flaps.push(new FlipUnit(0, "Minutos", 60));
            flaps.push(new FlipUnit(2.6, "Segundos", 60));

            clockCase = new THREE.Mesh(
                new THREE.BoxGeometry(8.8, 4.0, 0.4),
                new THREE.MeshStandardMaterial({ color: params.boxColor, roughness: 0.15, metalness: 0.85 })
            );
            clockCase.position.z = -0.45;
            scene.add(clockCase);

            initUI();
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const now = new Date();
            const h = now.getHours();
            const m = now.getMinutes();
            const s = now.getSeconds();

            const vals = [h, m, s];
            const nexts = [(h+1)%24, (m+1)%60, (s+1)%60];
            
            flaps.forEach((f, i) => {
                // Sincronização rigorosa do tempo
                if (f.currentVal !== vals[i] && !f.animating) {
                    f.setValues(vals[i], nexts[i]);
                }
                f.update(dt);
            });
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>

