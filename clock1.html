<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relógio 3D Industrial - Dark Mode</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            user-select: none;
            touch-action: none;
        }

        #ui-overlay {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        .label-main {
            color: #ffffff;
            font-size: 14px;
            font-weight: 800;
            letter-spacing: 6px;
            text-transform: uppercase;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        canvas { display: block; }
    </style>
</head>
<body>

<div id="ui-overlay">
    <div class="label-main">Optical Chronograph</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<!-- Shader para o Efeito de Magnificação (Lupa Óptica) -->
<script id="magnify-vertex" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>

<script id="magnify-fragment" type="x-shader/x-fragment">
    varying vec2 vUv;
    uniform sampler2D tNumbers;
    uniform float uLensY;      
    uniform float uLensHeight; 
    uniform float uMagnify;    

    void main() {
        vec2 uv = vUv;
        float dist = abs(uv.y - uLensY);
        
        if (dist < uLensHeight) {
            float normalizedDist = dist / uLensHeight;
            // Distorção esférica para simular a curvatura do vidro
            float distortion = (1.0 - pow(normalizedDist, 2.0)) * (uMagnify - 1.0);
            
            uv.y = uv.y - (uv.y - uLensY) * (distortion / uMagnify);
            uv.x = uv.x - (uv.x - 0.5) * (distortion / uMagnify);
        }

        vec4 tex = texture2D(tNumbers, uv);
        
        // Realce de brilho no centro da lente para simular luz focada
        float focus = smoothstep(uLensHeight, 0.0, dist);
        vec3 color = tex.rgb * (1.0 + focus * 0.4);
        
        gl_FragColor = vec4(color, tex.a);
    }
</script>

<script>
    // Configurações Globais
    const CONFIG = {
        bg: 0x000000,           // Fundo Preto
        trackColor: 0x1a1a1a,    // Trilhas Cinza Escuro Industrial
        frameColor: 0x444444,    // Aro da Lente (Metálico)
        spacing: 1.8,
        trackHeight: 9,
        trackWidth: 1.4,
        numPlaneHeight: 8.5, 
        lensMagnify: 1.8,
        lensArea: 0.1,
        snapSpeed: 0.15,
        idleResumeTime: 4000
    };

    let scene, camera, renderer, controls, raycaster;
    let columns = [];
    let isDragging = false;
    let activeColumn = null;
    let mouse = new THREE.Vector2();
    let prevMouseY = 0;
    let lastInteraction = 0;

    class Column {
        constructor(index, maxVal) {
            this.index = index;
            this.maxVal = maxVal;
            this.totalSlots = maxVal + 1;
            this.currentValue = 0; 
            this.targetValue = 0;  
            this.isAdjusting = false;

            this.group = new THREE.Group();
            this.group.position.x = (index - 2.5) * CONFIG.spacing;

            // 1. Corpo da Trilha
            const trackGeom = new THREE.BoxGeometry(CONFIG.trackWidth, CONFIG.trackHeight, 0.4);
            const trackMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.trackColor, 
                roughness: 0.5,
                metalness: 0.3
            });
            this.track = new THREE.Mesh(trackGeom, trackMat);
            this.group.add(this.track);

            // 2. Textura dos Números (Branco/Cinza claro para fundo preto)
            this.canvas = document.createElement('canvas');
            this.canvas.width = 256;
            this.canvas.height = 2048;
            const ctx = this.canvas.getContext('2d');
            this.numTexture = new THREE.CanvasTexture(this.canvas);
            
            ctx.clearRect(0, 0, 256, 2048);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '300 140px Inter, sans-serif';
            ctx.fillStyle = '#999999'; // Números mais claros para o Dark Mode
            
            const stepPx = 2048 / this.totalSlots;
            for(let i=0; i <= maxVal; i++) {
                const y = 2048 - (i * stepPx + stepPx/2);
                ctx.fillText(i, 128, y);
            }
            this.numTexture.needsUpdate = true;

            // 3. Plano com Shader de Magnificação
            this.shaderMat = new THREE.ShaderMaterial({
                uniforms: {
                    tNumbers: { value: this.numTexture },
                    uLensY: { value: 0.5 },
                    uLensHeight: { value: CONFIG.lensArea },
                    uMagnify: { value: CONFIG.lensMagnify }
                },
                vertexShader: document.getElementById('magnify-vertex').textContent,
                fragmentShader: document.getElementById('magnify-fragment').textContent,
                transparent: true
            });

            const numGeom = new THREE.PlaneGeometry(CONFIG.trackWidth * 0.9, CONFIG.numPlaneHeight);
            this.numMesh = new THREE.Mesh(numGeom, this.shaderMat);
            this.numMesh.position.z = 0.21;
            this.group.add(this.numMesh);

            // 4. Lente Física (Aro e Vidro)
            this.lensGroup = new THREE.Group();
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.frameColor, metalness: 0.8, roughness: 0.2 });
            this.lensGroup.add(new THREE.Mesh(new THREE.TorusGeometry(0.58, 0.04, 16, 64), frameMat));

            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transmission: 0.95,
                thickness: 0.5,
                roughness: 0.0,
                transparent: true,
                opacity: 0.4
            });
            const glass = new THREE.Mesh(new THREE.SphereGeometry(0.58, 32, 32, 0, Math.PI*2, 0, Math.PI*0.3), glassMat);
            glass.rotation.x = -Math.PI/2;
            glass.position.z = 0.05;
            this.lensGroup.add(glass);

            this.lensGroup.position.z = 0.35;
            this.group.add(this.lensGroup);

            scene.add(this.group);
        }

        update() {
            this.currentValue += (this.targetValue - this.currentValue) * CONFIG.snapSpeed;

            // Mapeamento preciso para o centro dos números
            const uvY = (this.currentValue + 0.5) / this.totalSlots;
            this.shaderMat.uniforms.uLensY.value = uvY;

            // Posicionamento Y sincronizado
            const yPos = (uvY - 0.5) * CONFIG.numPlaneHeight;
            this.lensGroup.position.y = yPos;
        }

        handleDrag(deltaY) {
            const sensitivity = 0.012;
            this.currentValue -= deltaY * sensitivity;
            this.currentValue = Math.max(0, Math.min(this.maxVal, this.currentValue));
            this.targetValue = this.currentValue;
        }

        snap() {
            this.targetValue = Math.round(this.currentValue);
            this.isAdjusting = false;
        }
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.bg);

        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Posição inicial: 35 graus horizontal e afastada
        const radius = 26;
        const angleRad = 35 * (Math.PI / 180);
        camera.position.set(radius * Math.sin(angleRad), 5, radius * Math.cos(angleRad));

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 10;
        controls.maxDistance = 40;

        // Iluminação dramática para Dark Mode
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        
        const mainLight = new THREE.PointLight(0xffffff, 1.0);
        mainLight.position.set(10, 15, 15);
        scene.add(mainLight);

        const blueRim = new THREE.PointLight(0x4444ff, 0.5); // Luz de contorno azulada sutil
        blueRim.position.set(-15, -5, -5);
        scene.add(blueRim);

        raycaster = new THREE.Raycaster();

        // Inicialização das 6 Colunas
        columns.push(new Column(0, 2)); 
        columns.push(new Column(1, 9)); 
        columns.push(new Column(2, 5)); 
        columns.push(new Column(3, 9)); 
        columns.push(new Column(4, 5)); 
        columns.push(new Column(5, 9)); 

        window.addEventListener('resize', onResize);
        window.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchstart', (e) => onDown(e.touches[0]), {passive: false});
        window.addEventListener('touchmove', (e) => onMove(e.touches[0]), {passive: false});
        window.addEventListener('touchend', onUp);

        animate();
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDown(e) {
        lastInteraction = Date.now();
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        prevMouseY = e.clientY;

        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(columns.map(c => c.track));

        if (hits.length > 0) {
            isDragging = true;
            controls.enabled = false;
            activeColumn = columns.find(c => c.track === hits[0].object);
            activeColumn.isAdjusting = true;
        }
    }

    function onMove(e) {
        if (!isDragging || !activeColumn) return;
        const deltaY = e.clientY - prevMouseY;
        activeColumn.handleDrag(deltaY);
        prevMouseY = e.clientY;
        lastInteraction = Date.now();
    }

    function onUp() {
        if (activeColumn) activeColumn.snap();
        isDragging = false;
        activeColumn = null;
        controls.enabled = true;
    }

    function updateTime() {
        const now = new Date();
        const time = [
            Math.floor(now.getHours() / 10), now.getHours() % 10,
            Math.floor(now.getMinutes() / 10), now.getMinutes() % 10,
            Math.floor(now.getSeconds() / 10), now.getSeconds() % 10
        ];

        const isIdle = Date.now() - lastInteraction > CONFIG.idleResumeTime;

        columns.forEach((col, i) => {
            if (!col.isAdjusting) {
                if (isIdle || i > 3) {
                    col.targetValue = time[i];
                }
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        updateTime();
        columns.forEach(c => c.update());
        controls.update();
        renderer.render(scene, camera);
    }

    window.onload = init;
</script>

</body>
</html>

